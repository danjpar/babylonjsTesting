<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Babylon.js demo</title>
<style>
html,body,canvas { margin: 0; padding: 0; width: 100%; height: 100%; font-size: 0; }
</style>
</head>
<body>
<script src='babylon.max.js'></script>
<canvas id='render-canvas'></canvas>
<script>
    var canvas = document.getElementById('render-canvas');
    var engine = new BABYLON.Engine(canvas);
    engine.enableOfflineSupport = false;

    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.8, 0.8, 0.8);

    var light = new BABYLON.PointLight('Omni', new BABYLON.Vector3(0, 0, 0), scene);

    scene.onBeforeRenderObservable.add(function () {     
        light.position = camera.position.clone();
    });

    var camera = new BABYLON.ArcRotateCamera('Camera', 0, 0, 20, new BABYLON.Vector3(0,0,0), scene);
    camera.beta = Math.PI/2 - .2;
    camera.alpha = Math.PI/2;
    camera.attachControl(canvas, false);
    camera.zoomingSensibility = 25;
    camera.panningSensibility = 50;

    var sourceMat = new BABYLON.StandardMaterial('sourceMat', scene);
    sourceMat.diffuseColor = new BABYLON.Color3.Black();
    sourceMat.backFaceCulling = false;
    
    var cylinder = BABYLON.MeshBuilder.CreateCylinder('cylinder', { diameter:2, tessellation:6 }, scene);
    cylinder.position.y += 1;
    //cylinder.computeWorldMatrix();
    var sphere = BABYLON.MeshBuilder.CreateSphere('sphere', { diameter:2 }, scene);
    sphere.position.y += 3;
    //sphere.computeWorldMatrix();
    var cube1 = BABYLON.MeshBuilder.CreateBox('cube1', {  }, scene);
    cube1.position.y += 4;
    cube1.position.x -= 1;
    //cube1.computeWorldMatrix();
    var cube2 = BABYLON.MeshBuilder.CreateBox('cube2', {  }, scene);
    cube2.position.y += 4;
    cube2.position.x += 1;
    var cube3 = BABYLON.MeshBuilder.CreateBox('cube2', {  }, scene);
    cube3.position.y += 3;
    cube3.position.z += 1;
    //cube2.computeWorldMatrix();
    var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 4, subdivsions: 4}, scene);
    //ground.computeWorldMatrix();
    var toExplode = BABYLON.Mesh.MergeMeshes([cylinder, sphere, cube1, cube2, cube3, ground], true, undefined, undefined, true);
    toExplode.material = sourceMat;
    //toExplode.position.x += 6;
    //toExplode.bakeCurrentTransformIntoVertices();

    var absCenter = toExplode._boundingInfo.boundingBox.centerWorld;

    var otherVertexData = BABYLON.VertexData.ExtractFromMesh(toExplode, true, true);
    var indices = otherVertexData.indices;
    var normals = otherVertexData.normals;
    var positions = otherVertexData.positions;
    var uvs = otherVertexData.uvs;
    var newMeshArray = [];
    for (var index = 0; index < toExplode.subMeshes.length; index++) {
        
        var newVertexData = new BABYLON.VertexData();
        
        var newI = indices.slice(toExplode.subMeshes[index].indexStart, toExplode.subMeshes[index].indexStart+toExplode.subMeshes[index].indexCount);
        var newP = positions.slice(toExplode.subMeshes[index].verticesStart * 3, toExplode.subMeshes[index].verticesStart * 3 + toExplode.subMeshes[index].verticesCount * 3);
        var newU = uvs.slice(toExplode.subMeshes[index].verticesStart * 2, toExplode.subMeshes[index].verticesStart * 2 + toExplode.subMeshes[index].verticesCount * 2);
        var newN = [];
        for (var subIndex = 0; subIndex < newI.length; subIndex++) {
            newI[subIndex] = newI[subIndex] - toExplode.subMeshes[index].verticesStart;
        }

        BABYLON.VertexData.ComputeNormals(newP, newI, newN);

        newVertexData.indices = newI;
        newVertexData.normals = newN;
        newVertexData.positions = newP;
        newVertexData.uvs = newU;
        
        var meshSubclass = new BABYLON.Mesh('new-'+index, scene);
        
        newVertexData.applyToMesh(meshSubclass);
                
        newMeshArray.push(meshSubclass);

    }
    toExplode.visibility = 0;
    var centerMesh = findCenterMesh(newMeshArray);
    moveRest(centerMesh, newMeshArray);
    /*
    for (var index = 0; index < newMeshArray.length; index++) {
        var bottomMesh = findBottom(newMeshArray);
        moveRest(bottomMesh, newMeshArray);
    }
    */
    function findCenterMesh(arr) {
        var centerMesh;
        var centerMeshIndex = 0;
        var distanceToCenter = Number.MAX_VALUE;
        for (var index = 0; index < arr.length; index++) {
            var v1 = absCenter;
            var v2 = arr[index]._boundingInfo.boundingBox.centerWorld;
            var v0 = v2.subtract(v1);
            var v3 = v0.length();
            if (v3 < distanceToCenter) {
                centerMesh = arr[index];
                distanceToCenter = v3;
                centerMeshIndex = index;
            }
        }
        arr.splice(centerMeshIndex, 1);
        return centerMesh;
    }
    //moveAll(newMeshArray);
    function moveAll(arr) {
        for (var index = 0; index < arr.length; index++) {
            var v1 = absCenter;
            var v2 = arr[index]._boundingInfo.boundingBox.centerWorld;
            var v0 = v2.subtract(v1);
            var v3 = v0.length();
            v0.normalize();
            arr[index].translate(v0, v3, BABYLON.Space.WORLD);
        }
    }

    function findBottom(arr) {
        var bottomMesh = arr[0];
        var bottomMeshIndex = 0;
        for (var index = 1; index < arr.length; index++) {
            if (arr[index]._boundingInfo.boundingBox.centerWorld.y < bottomMesh._boundingInfo.boundingBox.centerWorld.y) {
                bottomMesh = arr[index];
                bottomMeshIndex = index;
            }
        }
        arr.splice(bottomMeshIndex, 1);
        return bottomMesh;
    }

    function moveRest(mesh, arr) {
        for (var index = 0; index < arr.length; index++) {
            var v1 = mesh._boundingInfo.boundingBox.centerWorld;
            var v2 = arr[index]._boundingInfo.boundingBox.centerWorld;
            var v0 = v2.subtract(v1);
            var v3 = v0.length();
            v0.normalize();
            arr[index].translate(v0, v3, BABYLON.Space.WORLD);
        }
    }
/*

    var alpha = Math.PI;
    // Create a mesh for the trail to follow.
    var cube = BABYLON.MeshBuilder.CreateBox('cube', {  }, scene);
    cube.scaling.y = 2;
    cube.bakeCurrentTransformIntoVertices();
    cube.position.x = Math.sin(alpha)*10;
    cube.position.z = Math.cos(alpha)*10;
    cube.computeWorldMatrix(true);

    var trail = new BABYLON.TrailMesh('new', cube, scene, .5, 60, true);

    var sourceMat = new BABYLON.StandardMaterial('sourceMat', scene);
    sourceMat.emissiveColor = 
    sourceMat.diffuseColor = new BABYLON.Color3.Red();
    sourceMat.specularColor = new BABYLON.Color3.Black();

    trail.material = sourceMat;

    observer = scene.onBeforeRenderObservable.add(animate);
    function animate() {
        alpha += Math.PI/120;
        cube.position.x = Math.sin(alpha)*10;
        cube.position.z = Math.cos(alpha)*10;
        cube.rotation.x = Math.PI*alpha/2;
        cube.rotation.y = alpha;
    }
    setTimeout(function() {
        scene.onBeforeRenderObservable.remove(observer);
        newTrail.stop()
    }, 5000);
*/
    var renderLoop = function () {
        scene.render();
    };
    engine.runRenderLoop(renderLoop);

</script>
</body>
</html>
